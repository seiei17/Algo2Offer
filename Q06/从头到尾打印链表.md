# 06. 从头到尾打印链表

### 题目

```
输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：
输入：head = [1,3,2]
输出：[2,3,1]

限制：
0 <= 链表长度 <= 10000
```

##### 解法1：

遍历两次链表：第一次计算链表的长度，并创建数组；第二次将链表的值倒序放入数组中。

时间复杂度为O(n)，空间复杂度为O(1)。

```java
// 解法1：遍历两遍。第一次计算长度，第二次放入数组。
public int[] reversePrint1(ListNode head) {
  ListNode travel = head;
  int cnt = 0;
  while (travel != null) {
    cnt ++;
    travel = travel.next;
  }
  int[] res = new int[cnt --];
  while (head != null) {
    res[cnt --] = head.val;
    head = head.next;
  }
  return res;
}
```

##### 解法2：

使用stack来储存链表的值，在将stack的值导入数组。

时间复杂度为O(n)，空间复杂度为O(n)。

```java
// 解法2：用栈储存链表值。
public int[] reversePrint2(ListNode head) {
  Stack<Integer> stack = new Stack<>();
  while (head != null) {
    stack.push(head.val);
    head = head.next;
  }
  int n = stack.size();
  int[] res = new int[n + 1];
  for (int i = 0; i <= n && !stack.isEmpty(); i ++) {
    res[i] = stack.pop();
  }
  return res;
}
```

##### 解法3：

使用ArrayList来储存链表的值，再反向导入数组。

时间复杂度为O(n)，空间复杂度为O(n)。

```java
// 解法3：用ArrayList。
public int[] reversePrint3(ListNode head) {
  List<Integer> list = new ArrayList<>();
  while (head != null) {
    list.add(head.val);
    head = head.next;
  }
  int n = list.size();
  int[] res = new int[n];
  for (int i = 0; i < n; i ++) {
    res[i] = list.get(n - i - 1);
  }
  return res;
}
```

