# 最美子字符串的数目

[1915. 最美子字符串的数目 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-wonderful-substrings/)

## 分析

#### 公共前缀和

对于子字符串word[i...j]如果是最美字符串，说明其中最多只有一个字符出现奇数次：

>   如果每个字符的出现次数都是偶数，那么要求在word[0...i - 1]中字符的奇偶性要跟word[0...j]中的奇偶性一样。这样才能保证word[i, j]中出现的字符都是偶数次。
>
>   如果允许一个字符出现的次数是奇数次，那么说明允许一个字符在word[0...i - 1]和word[0...j]中的奇偶性不同。这样才能保证word[i, j]中出现的字符有一个是奇数次。

#### 字符串中字母出现次数的状态

只要求得知字符串中字母出现的奇偶性，且字母只包括在['a', 'j']之内，可以用一个10位的二进制数表示字母出现的奇偶性：0表示为偶数次、1表示为奇数次。

每次遍历一个字符，如果对应位为0，说明之前是偶数次，现在应该为奇数次1；如果对应位为1，说明之前是奇数次，现在应该为偶数次0。对于这个计算可以用异或运算来表示。 

#### 总思路

根据前面前缀和的推导，依次遍历字符串word，令当前遍历字符为k：

*   计算得到[0...k]的前缀和表达式mask。
*   查看[0...k-1]的子字符串中是否有前缀和为mask的。如果有，令下标为j，那么表示word[0...j]的前缀和也为mask，可以得知word[j+1...k]为最美字符串。于是有多少个前缀和为mask的子字符串，最美子字符串就有多少个。
*   上述考虑的是每个字符出现次数为偶数次的情况。对于仅有一个字符出现奇数次的情况，从0位到9位依次翻转mask的每一位得到mask\'。此时的mask\'表示有一位数的奇偶性与mask不同。查找[0...k-1]是否有前缀和为mask\'的子字符串，有多少个就说明最美字符串有多少个。

对于每次mask状态的储存，可以使用哈希表进行储存。

此外，因为一共只有10位变量，每个变量只能取0或者1，所以至多有2^10=1024个状态值。可以使用一个长度为1024的整型数组储存mask值，便于查找。

```java
class Solution {
    public long wonderfulSubstrings(String word) {
        int[] map = new int[1024];
        map[0] = 1;
        int mask = 0;
        long count = 0;
        for (char c: word.toCharArray()) {
            mask ^= 1 << c - 'a';
            count += map[mask];
            for (int i = 0; i < 10; i++) {
                count += map[mask ^ 1 << i];
            }
            map[mask]++;
        }
        return count;
    }
}
```

